"""
    humann(inputfile, output[, flags]; kwargs...)

Run `humann` command line tool on `inputfile`,
putting outputs in `output`.
Requires `humann` to be installed and accessible in the `PATH`
(see [Getting Started](@ref)).

`humann` flag options (those that don't have a parameter) can be passed in an array,
and other options can be passed with keyword arguments.
For example, if on the command line you would run:

```sh
\$ humann -i \$INPUTFILE -o \$OUTPUT --bypass-tranlated-search --input-format fastq.gz --output-format biom
```

using this function, you would write:

```julia
humann(INTPUTFILE, OUTPUT, ["bypass_translated_search"]; input_formal="fastq.gz", output_format="biom")
```
"""
function humann(inputfile, output, flags=[]; kwargs...)
    c = ["humann", "-i", inputfile, "-o", output]
    append!(c, [replace(string("--", f), "_"=>"-") for f in flags])
    append!(c, Iterators.flatten((replace(string("--", k), "_"=>"-"), v) for (k,v) in pairs(kwargs)))
    
    if !haskey(kwargs, :metaphlan_options) && haskey(ENV, "METAPHLAN_BOWTIE2_DB")
        append!(c, ["--metaphlan-options", "'--bowtie2db $(ENV["METAPHLAN_BOWTIE2_DB"])'"])
    end

    deleteat!(c, findall(==(""), c))
    @info "Running command: $(Cmd(c))"
    return run(Cmd(c))
end

function _gf_parse(gf)
    if occursin('|', gf) # indicates a taxon-stratified entry
        (gf, tax) = split(gf, '|')
        if tax == "unclassified"
            tax = Taxon("unclassified")
        else
            tm = contains(tax, "s__") ? match(r"(s__)(\w+)", tax) :
                 contains(tax, "g__") ? match(r"(g__)(\w+)", tax) :
                                        match(r"^(\W*)(\w+)$", tax)
            isnothing(tm) && error("Incorrectly formatted taxon stratification: $tax")
            cld = isnothing(tm.captures[1]) || tm.captures[1] == "s__" ? :species : :genus
            tax = Taxon(string(tm.captures[2]), cld)
        end
        return GeneFunction(gf, tax)
    else
        return GeneFunction(gf)
    end
end
"""
    humann_profile(path::AbstractString; sample=basename(first(splitext(path))), stratified=false)

Load a single functional profile generated by `HUMAnN`.
By default, skips rows that have species-stratified content,
use `stratified=true` to keep them.
"""
function humann_profile(path::AbstractString; sample=basename(first(splitext(path))), stratified=false)
    gfs = GeneFunction[]
    abundances = Float64[]
    
    for (i, (gf, abundance)) in enumerate(CSV.File(path, datarow=2, header=["function", "abundance"]))   
        (!stratified && occursin('|', gf)) && continue
        push!(gfs, _gf_parse(gf))
        push!(abundances, abundance)
    end
    mat = sparse(reshape(abundances, length(abundances), 1))
    sample = sample isa Microbiome.AbstractSample ? sample : MicrobiomeSample(sample)

    return CommunityProfile(mat, gfs, [sample])
end

"""

"""
function humann_profiles(path::AbstractString; samples=nothing, stratified=false)
    tbl = CSV.File(path)
    gfs = GeneFunction[]
    if !isnothing(samples) 
        length(samples) == length(keys(first(tbl))) - 1 || throw(ArgumentError("Passed $(length(samples)) samples, but table has $(length(keys(first(tbl))) - 1)"))
    else
        samples = keys(first(tbl))[2:end]
    end

    stratified || (tbl = filter(row-> !occursin('|', row[1]), tbl))
    mat = spzeros(length(tbl), length(samples))

    for (i, (row)) in enumerate(tbl)
        push!(gfs, _gf_parse(row[1]))
        for j in 1:length(samples)
            mat[i, j] = ismissing(row[j+1]) ? 0 : row[j+1]
        end
    end
    samples = eltype(samples) == MicrobiomeSample ? samples : MicrobiomeSample.(string.(samples))
    return CommunityProfile(mat, gfs, samples)
end

"""
    function humann_regroup(comm::CommunityProfile; inkind="uniref90", outkind::String="ec")

Wrapper for `humann_regroup` script,
replaces first column of a DataFrame with results from
regrouping `inkind` to `outkind`.

Requires installation of [`humann`](https://github.com/biobakery/humann) available in `ENV["PATH"]`.
See "[Using Conda](@ref)" for more information.
"""
function humann_regroup(comm::CommunityProfile; inkind::String="uniref90", outkind::String="ec")
    in_path = tempname()
    out_path = tempname()

    ss = samples(comm)
    CSV.write(in_path, comm; delim='\t')
    run(```
        humann_regroup_table -i $in_path -g $(inkind)_$outkind -o $out_path
        ```)

    return humann_profiles(out_path; samples=ss)
end

"""
    humann_rename(comm::AbstractDataFrame; kind::String="ec")

Wrapper for `humann_rename` script,
replaces first column of a DataFrame with results from
renaming `inkind` to `outkind`.

Requires installation of [`humann`](https://github.com/biobakery/humann) available in `ENV["PATH"]`.
See "[Using Conda](@ref)" for more information.
"""
function humann_rename(comm::CommunityProfile; kind::String="ec")
    in_path = tempname()
    out_path = tempname()
    ss = samples(comm)
    
    CSV.write(in_path, comm; delim='\t')
    run(```
        humann_rename_table -i $in_path -n $kind -o $out_path
        ```)
    
    return humann_profiles(out_path; samples=ss)
end

function humann_renorm(comm::CommunityProfile; units="cpm")
    in_path = tempname()
    out_path = tempname()
    ss = samples(comm)
    
    CSV.write(in_path, comm; delim='\t')
    run(```
        humann_renorm_table -i $in_path --units $units -o $out_path
        ```)
    
    return humann_profiles(out_path; samples=ss)
end


# function humann_barplots(df::AbstractDataFrame, metadata::AbstractArray{<:AbstractString,1}, outpath::String)
#     length(metadata) == size(df, 2) - 1 || @error "Must have metadata for each column"
#     nostrat = df[map(x-> !occursin(r"\|", x), df[!,1]), 1]
#     for p in nostrat
#         pwy = match(r"^[\w.]+", p).match
#         @debug pwy
#         filt = [occursin(Regex("^$pwy\\b"), x) for x in df[!,1]]
#         current = df[filt, :]
#         @debug "Size of $p dataframe" size(current)
#         if size(current, 1) < 3
#             @info "Only 1 classified species for $p, skipping"
#             continue
#         end
#         @info "plotting $p"

#         BiobakeryUtils.humann_barplot(current, metadata, outpath)
#     end
# end

# function humann_barplot(df::AbstractDataFrame, metadata::AbstractArray{<:AbstractString,1}, outpath::AbstractString)
#     sum(x-> !occursin(r"\|", x), df[!,1]) == 1 || @error "Multipl unstratified rows in dataframe"
#     matches = map(x-> match(r"^([^:|]+):?([^|]+)?", x),  df[!,1])
#     all(x-> !isa(x, Nothing), matches) || @error "something is wrong!"
#     @debug "Getting unique"
#     ecs = unique([String(x.captures[1]) for x in matches])
#     length(ecs) == 1 || @error "Multiple ecs found in df"
#     ec = ecs[1]

#     metadf = DataFrame(metadata=["metadatum"])
#     metadf = hcat(metadf, DataFrame([names(df)[2:end][i]=>metadata[i] for i in eachindex(metadata)]...))
#     @debug "opening file"
#     fl_path = tempname()
#     outfl = open(fl_path, "w")
#     CSV.write(outfl, metadf, delim='\t')
#     CSV.write(outfl, df, append=true, delim='\t')
#     close(outfl)
#     @debug "file closed"

#     out = joinpath(outpath, "$ec.png")
#     @debug "humann_barplot --i $fl_path -o $out --focal-feature $ec --focal-metadatum metadatum --last-metadatum metadatum --sort sum metadata"
#     run(```
#         humann_barplot --i $fl_path -o "$out" --focal-feature "$ec" --focal-metadatum metadatum --last-metadatum metadatum --sort sum metadata
#         ```)

# end
