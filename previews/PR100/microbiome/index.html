<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Microbiome.jl Docstrings · BiobakeryUtils.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="http://docs.ecojulia.org/BiobakeryUtils.jl/stable/microbiome/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BiobakeryUtils.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">BiobakeryUtils</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../kneaddata/">Working with KneadData</a></li><li><a class="tocitem" href="../metaphlan/">Working with MetaPhlAn</a></li><li><a class="tocitem" href="../humann/">Working with HUMAnN</a></li><li class="is-active"><a class="tocitem" href>Microbiome.jl Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Microbiome.jl Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Microbiome.jl Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EcoJulia/BiobakeryUtils.jl/blob/main/docs/src/microbiome.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Microbiome.jl-functions"><a class="docs-heading-anchor" href="#Microbiome.jl-functions">Microbiome.jl functions</a><a id="Microbiome.jl-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Microbiome.jl-functions" title="Permalink"></a></h1><p><code>BiobakeryUtils.jl</code> re-exports all of the functionality from <a href="https://github.com/EcoJulia/Microbiome.jl"><code>Microbiome.jl</code></a>. The docstrings from that package are reproduced here, but checkout the <a href="https://docs.ecojulia.org/Microbiome.jl/stable/">Microbiome.jl docs</a> for more details.</p><article class="docstring"><header><a class="docstring-binding" id="Microbiome.CommunityProfile" href="#Microbiome.CommunityProfile"><code>Microbiome.CommunityProfile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CommunityProfile{T, F, S} &lt;: AbstractAbundanceTable{T, F, S}</code></pre><p>An <code>AbstractAssemblage</code> from <a href="https://github.com/EcoJulia/EcoBase.jl">EcoBase.jl</a> that uses a <code>SparseMatrixCSC</code> under the hood.</p><p><code>CommunityProfile</code>s are tables with <code>AbstractFeature</code>-indexed rows and <code>AbstractSample</code>-indexed columns. Note - we can use the <code>name</code> of samples and features to index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.GeneFunction" href="#Microbiome.GeneFunction"><code>Microbiome.GeneFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneFunction(name::String, taxon::Union{Taxon, String, Missing}) &lt;: AbstractFeature
GeneFunction(name::String)</code></pre><p>Microbial gene function object with optional stratification (<code>taxon</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.Metabolite" href="#Microbiome.Metabolite"><code>Microbiome.Metabolite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Metabolite(name::String, commonname::Union{Missing, String}, mz::Union{Missing, Float64}, rt::Union{Missing, Float64}) &lt;: AbstractFeature
Metabolite(name::String)</code></pre><p>Represents a small-molecule metabolite coming from an LCMS. The fields are</p><ul><li><code>name</code>: required, this should be a unique identifier</li><li><code>commonname</code>: might refer to a chemical name like &quot;proprionate&quot;</li><li><code>mz</code>: The mass/charge ratio</li><li><code>rt</code>: The retention time</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.MicrobiomeSample" href="#Microbiome.MicrobiomeSample"><code>Microbiome.MicrobiomeSample</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MicrobiomeSample(name::String, metadata::Dictionary{Symbol, T}) &lt;: AbstractSample
MicrobiomeSample(name::String; kwargs...)
MicrobiomeSample(name::String)</code></pre><p>Microbiome sample type that includes a name and a <a href="https://github.com/andyferris/Dictionaries.jl"><code>Dictionary</code></a> of arbitrary metadata using <code>Symbol</code>s (other than <code>:name</code> or <code>:metadata</code>) as keys.</p><p>Metadata can be accessed using <code>getproperty</code> or <code>getindex</code> on the sample itself.</p><p>Samples can be instantiated with only a name, leaving the <code>metadata</code> <code>Dictionary</code> blank</p><p>Adding or changing metadata follows <a href="https://github.com/andyferris/Dictionaries.jl#accessing-dictionaries">the same rules</a> as for the normal <code>Dictionary</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.Taxon" href="#Microbiome.Taxon"><code>Microbiome.Taxon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Taxon(name::String, rank::Union{Missing, Symbol, Int}) &lt;: AbstractFeature
Taxon(name::String)</code></pre><p>Microbial taxon with a name and a rank that can be one of </p><ol><li><code>:domain</code></li><li><code>:kingom</code></li><li><code>:phylum</code></li><li><code>:class</code></li><li><code>:order</code></li><li><code>:faamily</code></li><li><code>:genus</code></li><li><code>:species</code></li><li><code>:subspecies</code></li><li><code>:strain</code></li></ol><p>or <code>missing</code>. Contructors can also use numbers 0-9, or pass a string alone (in which case the <code>taxon</code> will be stored as <code>missing</code>).</p><p>See also <a href="#Microbiome.taxon-Tuple{AbstractString}"><code>taxon</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{AbstractSample, Symbol}" href="#Base.delete!-Tuple{AbstractSample, Symbol}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete!(as::AbstractSample, prop::Symbol)</code></pre><p>Delete a metadata entry of sample <code>as</code> using the Symbol <code>prop</code> if it exists, or throw an error otherwise. If you don&#39;t want an error to be thrown if the value does not exist, use <a href="#Dictionaries.unset!-Tuple{AbstractSample, Symbol}"><code>unset!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{CommunityProfile, AbstractString, Symbol}" href="#Base.delete!-Tuple{CommunityProfile, AbstractString, Symbol}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete!(commp::CommunityProfile, sample::AbstractString, prop::Symbol)</code></pre><p>Delete a metadata entry in <code>sample</code> from CommunityProfile <code>commp</code> using the Symbol <code>prop</code> if it exists, or throw an error otherwise. If you don&#39;t want an error to be thrown if the value does not exist, use <a href="#Dictionaries.unset!-Tuple{AbstractSample, Symbol}"><code>unset!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Tuple{Function, CommunityProfile}" href="#Base.filter-Tuple{Function, CommunityProfile}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter(f, comm::CommunityProfile)</code></pre><p>Apply <code>f</code> to the features of <code>comm</code>, and return a copy where <code>f(feature)</code> is <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get(commp::CommunityProfile, key::Symbol, default)</code></pre><p>Return the value of the metadata in a <code>sample</code> stored for the given <code>key</code>, or the given <code>default</code> value if no mapping for the key is present.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get(commp::CommunityProfile, sample::AbstractString, key::Symbol, default)</code></pre><p>Return the value of the metadata in a <code>sample</code> stored for the given <code>key</code>, or the given <code>default</code> value if no mapping for the key is present.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Tuple{AbstractSample, Symbol, Any}" href="#Base.get-Tuple{AbstractSample, Symbol, Any}"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get(as::AbstractSample, key::Symbol, default)</code></pre><p>Return the value of the metadata in the sample <code>as</code> stored for the given <code>key</code>, or the given <code>default</code> value if no mapping for the key is present.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractSample, Symbol}" href="#Base.getindex-Tuple{AbstractSample, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(as::AbstractSample, prop::Symbol)</code></pre><p>Return the <code>prop</code> value in the metadata dictionary of <code>as</code>. This enables using bracket syntax for access, eg <code>as[prop]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{AbstractSample, Symbol}" href="#Base.getproperty-Tuple{AbstractSample, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getproperty(as::AbstractSample, prop::Symbol)</code></pre><p>Return the <code>prop</code> value in the metadata dictionary of <code>as</code>. This enables using dot syntax for access, eg <code>as.prop</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{AbstractSample, Symbol}" href="#Base.haskey-Tuple{AbstractSample, Symbol}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">haskey(as::AbstractSample, key::Symbol)</code></pre><p>Determine whether the metadata of sample <code>as</code> has a mapping for a given <code>key</code>.  Use <code>!haskey</code> to determine whether a sample <code>as</code> in a CommunityProfile doesn&#39;t have a mapping for a given <code>key</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{CommunityProfile, AbstractString, Symbol}" href="#Base.haskey-Tuple{CommunityProfile, AbstractString, Symbol}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">haskey(commp::CommunityProfile, sample::AbstractString, key::Symbol)</code></pre><p>Determine whether the metadata of <code>sample</code> in a CommunityProfile <code>commp</code> has a mapping for a given <code>key</code>.  Use <code>!haskey</code> to determine whether a <code>sample</code> in a CommunityProfile doesn&#39;t have a mapping for a given <code>key</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!-Tuple{AbstractSample, Symbol, Any}" href="#Base.insert!-Tuple{AbstractSample, Symbol, Any}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert!(as::AbstractSample, prop::Symbol, val)</code></pre><p>Insert a value <code>val</code> to the metadata of sample <code>as</code> using a Symbol <code>prop</code>,  and it will throw an error if <code>prop</code> exists.  If you don&#39;t want an error to be thrown if the value exists, use <a href="#Dictionaries.set!-Tuple{AbstractSample, Symbol, Any}"><code>set!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!-Tuple{CommunityProfile, AbstractString, Symbol, Any}" href="#Base.insert!-Tuple{CommunityProfile, AbstractString, Symbol, Any}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert!(commp::CommunityProfile, sample::AbstractString, prop::Symbol, val)</code></pre><p>Insert a value <code>val</code> to the metadata of <code>sample</code> in a CommunityProfile <code>commp</code> using a Symbol <code>prop</code>,  and it will throw an error if <code>prop</code> exists.  If you don&#39;t want an error to be thrown if the value exists, use <a href="#Dictionaries.set!-Tuple{AbstractSample, Symbol, Any}"><code>set!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!-Tuple{CommunityProfile, Any}" href="#Base.insert!-Tuple{CommunityProfile, Any}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert!(cp::CommunityProfile, md; namecol=:sample)</code></pre><p>Add metadata (in the form of a <code>Tables.jl</code> table) a <code>CommunityProfile</code>. One column (<code>namecol</code>) should contain sample names that exist in <code>commp</code>, and other columns should contain metadata that will be added to the metadata of each sample.</p><p>Before starting, this will check that every value in every row is <code>insert!</code>able, and will throw an error if not. This requires iterating over the metadata table twice, which may be slow. If performance matters, you can use <code>set!</code> instead,  though this will overwrite existing data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{AbstractSample}" href="#Base.keys-Tuple{AbstractSample}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keys(as::AbstractSample)</code></pre><p>Return an iterator over all keys of the metadata attached to sample <code>as</code>.  <code>collect(keys(as))</code> returns an array of keys. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{CommunityProfile, AbstractString}" href="#Base.keys-Tuple{CommunityProfile, AbstractString}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keys(commp::CommunityProfile, sample::AbstractString)</code></pre><p>Return an iterator over all keys of the metadata attached to <code>sample</code> in a CommunityProfile <code>commp</code>.  <code>collect(keys(commp, sample))</code> returns an array of keys. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dictionaries.set!-Tuple{AbstractSample, Symbol, Any}" href="#Dictionaries.set!-Tuple{AbstractSample, Symbol, Any}"><code>Dictionaries.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set!(as::AbstractSample, prop::Symbol, val)</code></pre><p>Update or insert a value <code>val</code> to the metadata of sample <code>as</code> using a Symbol <code>prop</code>.  If you want an error to be thrown if the value already exists, use <a href="#Base.insert!-Tuple{AbstractSample, Symbol, Any}"><code>insert!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dictionaries.set!-Tuple{CommunityProfile, AbstractString, Symbol, Any}" href="#Dictionaries.set!-Tuple{CommunityProfile, AbstractString, Symbol, Any}"><code>Dictionaries.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set!(commp::CommunityProfile, sample::AbstractString, prop::Symbol, val)
set!(commp::CommunityProfile, sample::AbstractString, md::Union{AbstractDict, NamedTuple})</code></pre><p>Update or insert a value <code>val</code> to the metadata of <code>sample</code> in the CommunityProfile <code>commp</code> using a Symbol <code>prop</code>.  If you want an error to be thrown if the value already exists, use <a href="#Base.insert!-Tuple{AbstractSample, Symbol, Any}"><code>insert!</code></a>.</p><p>Can also pass a Dictionary or NamedTuple containing key=&gt; value pairs, all of which will be <code>set!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dictionaries.set!-Tuple{CommunityProfile, Any}" href="#Dictionaries.set!-Tuple{CommunityProfile, Any}"><code>Dictionaries.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set!(cp::CommunityProfile, md; namecol=:sample)</code></pre><p>Add metadata (in the form of a <code>Tables.jl</code> table) a <code>CommunityProfile</code>. One column (<code>namecol</code>) should contain sample names that exist in <code>commp</code>, and other columns should contain metadata that will be added to the metadata of each sample.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dictionaries.unset!-Tuple{AbstractSample, Symbol}" href="#Dictionaries.unset!-Tuple{AbstractSample, Symbol}"><code>Dictionaries.unset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unset!(as::AbstractSample, prop::Symbol)</code></pre><p>Delete a metadata entry of sample <code>as</code> using the Symbol <code>prop</code>.  If you want an error to be thrown if the value does not exist, use <a href="#Base.delete!-Tuple{AbstractSample, Symbol}"><code>delete!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dictionaries.unset!-Tuple{CommunityProfile, AbstractString, Symbol}" href="#Dictionaries.unset!-Tuple{CommunityProfile, AbstractString, Symbol}"><code>Dictionaries.unset!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>unset!(commp::CommunityProfile, sample::AbstractString, prop::Symbol)</p><p>Delete a metadata entry in <code>sample</code> from CommunityProfile <code>commp</code> using the Symbol <code>prop</code>.  If you want an error to be thrown if the value does not exist, use <a href="#Base.delete!-Tuple{AbstractSample, Symbol}"><code>delete!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.abundances" href="#Microbiome.abundances"><code>Microbiome.abundances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abundances(at::AbstractAbundanceTable)</code></pre><p>Get the underlying sparse matrix of an <code>AbstractAbundanceTable</code>. Note that this does not copy - any modifications to this matrix will update the parent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.braycurtis-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.braycurtis-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.braycurtis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">braycurtis(abt::AbstractAbundanceTable)</code></pre><p>Returns a pairwise Bray-Curtis dissimilarity matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.commjoin-Tuple{CommunityProfile, Vararg{CommunityProfile}}" href="#Microbiome.commjoin-Tuple{CommunityProfile, Vararg{CommunityProfile}}"><code>Microbiome.commjoin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commjoin(c1::CommunityProfile, comms::CommunityProfile...)</code></pre><p>Join multiple <code>CommunityProfile</code>s, creating a new <code>CommunityProfile</code>. For now, sample names cannot overlap in any of the input profiles.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.commonname-Tuple{Metabolite}" href="#Microbiome.commonname-Tuple{Metabolite}"><code>Microbiome.commonname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commonname(m::Metabolite)</code></pre><p>Accessor function for the <code>commonname</code> field of a <a href="#Microbiome.Metabolite"><code>Metabolite</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.featurenames" href="#Microbiome.featurenames"><code>Microbiome.featurenames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">featurenames(at::AbstractAbundanceTable)</code></pre><p>Get a vector of feature names from <code>at</code>, equivalent to <code>name.(features(at))</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.features-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.features-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.features</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">features(at::AbstractAbundanceTable)</code></pre><p>Returns features in <code>at</code>. To get featurenames instead, use <a href="#Microbiome.featurenames"><code>featurenames</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.featuretotals-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.featuretotals-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.featuretotals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">featuretotals(at::AbstractAbundanceTable)</code></pre><p>Returns sum of each row (feature) in <code>at</code>. Note, return value is a nfeatures x 1 <code>Matrix</code>, not a <code>Vector</code>. If you need 1D <code>Vector</code>, use <code>vec(featuretotals(at))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.functionalprofile-Tuple{Any, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:AbstractString}}" href="#Microbiome.functionalprofile-Tuple{Any, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:AbstractString}}"><code>Microbiome.functionalprofile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">functionalprofile(mat, features, samples)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.genefunction-Tuple{AbstractString}" href="#Microbiome.genefunction-Tuple{AbstractString}"><code>Microbiome.genefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genefunction(n::AbstractString)</code></pre><p>Make a <a href="#Microbiome.GeneFunction"><code>GeneFunction</code></a> from a string, Converting anything after an initial <code>|</code> as a <a href="#Microbiome.Taxon"><code>Taxon</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.ginisimpson!-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.ginisimpson!-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.ginisimpson!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ginisimpson!(abt::AbstractAbundanceTable; overwrite=false)</code></pre><p>Adds a <code>:ginisimpson</code> entry to the metadata for each sample in <code>abt</code> with the Gini-Simpson alpha diversity of that sample (see <a href="#Microbiome.ginisimpson-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T}}}, Tuple{T}} where T&lt;:Real"><code>ginisimpson</code></a>). If <code>overwrite=false</code> (the default), uses <code>insert!</code> to perform this operation, so an error will be thrown if any sample already contains a <code>:ginisimpson</code> entry. Otherwise, uses <code>set!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.ginisimpson-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T}}}, Tuple{T}} where T&lt;:Real" href="#Microbiome.ginisimpson-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T}}}, Tuple{T}} where T&lt;:Real"><code>Microbiome.ginisimpson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ginisimpson(v::Union{AbstractVector, AbstractSparseMatrix}) 
ginisimpson(abt::AbstractAbundanceTable, overwrite=false)</code></pre><p>Computes the Gini-Simpson alpha diversity metric for a vector. When called on an <code>AbstractAbundanceTable</code>, returns a 1 x nsamples matrix with 1 entry per sample. See also <a href="#Microbiome.ginisimpson!-Tuple{Microbiome.AbstractAbundanceTable}"><code>ginisimpson!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.hasrank-Tuple{GeneFunction}" href="#Microbiome.hasrank-Tuple{GeneFunction}"><code>Microbiome.hasrank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasrank(gf::GeneFunction)::Bool</code></pre><p>Boolean function that returns:</p><ul><li><code>true</code> if <code>gf</code> has a <a href="#Microbiome.Taxon"><code>Taxon</code></a> with a non-missing <code>rank</code> field,</li><li><code>false</code> if there&#39;s no <code>Taxon</code>, or </li><li><code>false</code> if the <code>Taxon</code> has no <code>rank</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.hasrank-Tuple{Taxon}" href="#Microbiome.hasrank-Tuple{Taxon}"><code>Microbiome.hasrank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasrank(t::Taxon)::Bool</code></pre><p>Boolean function that returns <code>true</code> if the <code>rank</code> field in <a href="#Microbiome.Taxon"><code>Taxon</code></a> <code>t</code> is not <code>missing</code>, or <code>false</code> if it is <code>missing</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.hastaxon-Tuple{GeneFunction}" href="#Microbiome.hastaxon-Tuple{GeneFunction}"><code>Microbiome.hastaxon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hastaxon(gf::GeneFunction)::Bool</code></pre><p>Boolean function that returns <code>true</code> if the <code>taxon</code> field in a <a href="#Microbiome.GeneFunction"><code>GeneFunction</code></a> <code>gf</code> is not <code>missing</code>, or <code>false</code> if it is <code>missing</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.hellinger-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.hellinger-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.hellinger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hellinger(abt::AbstractAbundanceTable)</code></pre><p>Returns a pairwise Hellinger distance matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.jaccard-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.jaccard-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.jaccard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jaccard(abt::AbstractAbundanceTable)</code></pre><p>Returns a pairwise Jaccard distance matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.masscharge-Tuple{Metabolite}" href="#Microbiome.masscharge-Tuple{Metabolite}"><code>Microbiome.masscharge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">masscharge(m::Metabolite)</code></pre><p>Accessor function for the <code>mz</code> field of a <a href="#Microbiome.Metabolite"><code>Metabolite</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.metabolicprofile-Tuple{Any, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:AbstractString}}" href="#Microbiome.metabolicprofile-Tuple{Any, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:AbstractString}}"><code>Microbiome.metabolicprofile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metabolicprofile(mat, features, samples)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.metadata-Tuple{AbstractSample}" href="#Microbiome.metadata-Tuple{AbstractSample}"><code>Microbiome.metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata(t::AbstractSample)</code></pre><p>Get the <code>metadata</code> field from an <code>AbstractSample</code>. Note that this is not a copy, so modifications to the returned value will update the parent <code>AbstractSample</code> as well.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.metadata-Tuple{CommunityProfile}" href="#Microbiome.metadata-Tuple{CommunityProfile}"><code>Microbiome.metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata(commp::CommunityProfile)</code></pre><p>Returns iterator of <code>NamedTuple</code> per sample, where keys are <code>:sample</code> and each metadata key found in <code>commp</code>. Samples without given metadata are filled with <code>missing</code>.</p><p>Returned values can be passed to any Tables.rowtable - compliant type, eg <code>DataFrame</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.name-Tuple{AbstractSample}" href="#Microbiome.name-Tuple{AbstractSample}"><code>Microbiome.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(t::Union{AbstractSample, AbstractFeature})</code></pre><p>Get the <code>name</code> field from an <code>AbstractSample</code> or <code>AbstractFeature</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.pcoa" href="#Microbiome.pcoa"><code>Microbiome.pcoa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pcoa(abt::AbstractAbundanceTable, f=braycurtis)</code></pre><p>Returns eigenvectors from fitting <code>MDS</code> to a distance metric generated by <code>f</code>, by default <code>braycurtis</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.present" href="#Microbiome.present"><code>Microbiome.present</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">present(t::Union{Real, Missing}, minabundance::Real=0.0)
present(at::AbstractAbundanceTable, minabundance::Real=0.0)</code></pre><p>Check if a given (non-zero) value is greater than or equal to a minimum value. If the minimum abundance is 0, just checks if value is non-zero.</p><p>If used on an <code>AbstractAbundanceTable</code>, returns a sparse boolean matrix of the same size.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.prevalence" href="#Microbiome.prevalence"><code>Microbiome.prevalence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prevalence(a::AbstractArray{&lt;:Real}, minabundance::Real=0.0)
prevalence(at::AbstractAbundanceTable, minabundance::Real=0.0)</code></pre><p>Return the fraction of values that are greater than or equal to a minimum. If the minimum abundance is 0, returns the fraction of non-zero values.</p><p>If used on an <code>AbstractAbundanceTable</code>, returns a prevalence value for each <code>feature</code> accross the <code>sample</code>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.prevalence_filter-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.prevalence_filter-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.prevalence_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevalence_filter(comm::AbstractAbundanceTable; minabundance=0.0; minprevalence=0.05, renorm=false)</code></pre><p>Return a filtered <code>CommunityProfile</code> where features with prevalence lower than <code>minprevalence</code> are removed. By default, a feature is considered &quot;present&quot; if &gt; 0, but this can be changed by setting <code>minabundance</code>.</p><p>Optionally, set <code>renorm = true</code> to calculate relative abundances after low prevalence features are removed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.rankfilter-Tuple{Microbiome.AbstractAbundanceTable, Symbol}" href="#Microbiome.rankfilter-Tuple{Microbiome.AbstractAbundanceTable, Symbol}"><code>Microbiome.rankfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rankfilter(comm::AbstractAbundanceTable, cl::Union{Symbol, Int}; keepempty=false)</code></pre><p>Return a copy of <code>comm</code>, where only rows that have <code>taxrank(feature) == cl</code> are kept. Use <code>keepempty = true</code> to also keep features that don&#39;t have a <code>rank</code> (eg &quot;UNIDENTIFIED&quot;).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.relativeabundance" href="#Microbiome.relativeabundance"><code>Microbiome.relativeabundance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relativeabundance(at::AbstractAbundanceTable, kind::Symbol=:fraction)</code></pre><p>Like <a href="#Microbiome.relativeabundance!-Tuple{Microbiome.AbstractAbundanceTable}"><code>relativeabundance!</code></a>, but does not mutate original.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.relativeabundance!-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.relativeabundance!-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.relativeabundance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relativeabundance!(a::AbstractAbundanceTable; kind::Symbol=:fraction)</code></pre><p>Normalize each sample in AbstractAbundanceTable to the sum of the sample.</p><p>By default, columns sum to 1.0. Use <code>kind=:percent</code> for columns to sum to 100.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.retentiontime-Tuple{Metabolite}" href="#Microbiome.retentiontime-Tuple{Metabolite}"><code>Microbiome.retentiontime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retentiontime(m::Metabolite)</code></pre><p>Accessor function for the <code>rt</code> field of a <a href="#Microbiome.Metabolite"><code>Metabolite</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.runtests-Tuple" href="#Microbiome.runtests-Tuple"><code>Microbiome.runtests</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Microbiome.runtests(pattern...; kwargs...)</code></pre><p>Equivalent to <code>ReTest.retest(Microbiome, pattern...; kwargs...)</code>. This function is defined automatically in any module containing a <code>@testset</code>, possibly nested within submodules.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.samplenames" href="#Microbiome.samplenames"><code>Microbiome.samplenames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">samplenames(at::AbstractAbundanceTable)</code></pre><p>Get a vector of sample names from <code>at</code>, equivalent to <code>name.(samples(at))</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.samples-Tuple{Microbiome.AbstractAbundanceTable, AbstractString}" href="#Microbiome.samples-Tuple{Microbiome.AbstractAbundanceTable, AbstractString}"><code>Microbiome.samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">samples(at::AbstractAbundanceTable, name::AbstractString)</code></pre><p>Returns sample in <code>at</code> with name <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.samples-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.samples-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">samples(at::AbstractAbundanceTable)</code></pre><p>Returns samples in <code>at</code>. To get samplenames instead, use <a href="#Microbiome.samplenames"><code>samplenames</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.sampletotals-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.sampletotals-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.sampletotals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampletotals(at::AbstractAbundanceTable)</code></pre><p>Returns sum of each row (feature) in <code>at</code>. Note, return value is a 1 x nsamples <code>Matrix</code>, not a <code>Vector</code>. If you need 1D <code>Vector</code>, use <code>vec(sampletotals(at))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.shannon!-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.shannon!-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.shannon!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shannon!(abt::AbstractAbundanceTable; overwrite=false)</code></pre><p>Adds a <code>:shannon</code> entry to the metadata for each sample in <code>abt</code> with the Shannon alpha diversity of that sample (see <a href="#Microbiome.shannon-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T}}}, Tuple{T}} where T&lt;:Real"><code>shannon</code></a>). If <code>overwrite=false</code> (the default), uses <code>insert!</code> to perform this operation, so an error will be thrown if any sample already contains a <code>:shannon</code> entry. Otherwise, uses <code>set!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.shannon-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T}}}, Tuple{T}} where T&lt;:Real" href="#Microbiome.shannon-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T}}}, Tuple{T}} where T&lt;:Real"><code>Microbiome.shannon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shannon(v::Union{AbstractVector, AbstractSparseMatrix}) 
shannon(abt::AbstractAbundanceTable)</code></pre><p>Computes the Shannon alpha diversity metric for a vector. When called on an <code>AbstractAbundanceTable</code>, returns a 1 x nsamples matrix with 1 entry per sample. See also <a href="#Microbiome.shannon!-Tuple{Microbiome.AbstractAbundanceTable}"><code>shannon!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.taxon-Tuple{AbstractString}" href="#Microbiome.taxon-Tuple{AbstractString}"><code>Microbiome.taxon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">taxon(::AbstractString)</code></pre><p>Return a <a href="#Microbiome.Taxon"><code>Taxon</code></a> from a string representation. If the string contains taxonomic rank information in the form <code>&quot;x__Thename&quot;</code> where <code>x</code> is the first letter of the rank, this information will be used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; taxon(&quot;Unknown&quot;)
Taxon(&quot;Unknown&quot;, missing)

julia&gt; taxon(&quot;s__Prevotella_copri&quot;)
Taxon(&quot;Prevotella_copri&quot;, :species)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.taxon-Tuple{GeneFunction}" href="#Microbiome.taxon-Tuple{GeneFunction}"><code>Microbiome.taxon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">taxon(gf::GeneFunction)</code></pre><p>Get the <code>taxon</code> field from a <a href="#Microbiome.GeneFunction"><code>GeneFunction</code></a>, <code>gf</code>. Returns <code>missing</code> if the taxon is not set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.taxonomicprofile-Tuple{Any, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:AbstractString}}" href="#Microbiome.taxonomicprofile-Tuple{Any, AbstractVector{&lt;:AbstractString}, AbstractVector{&lt;:AbstractString}}"><code>Microbiome.taxonomicprofile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">taxonomicprofile(mat, features, samples)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.taxrank-Tuple{GeneFunction}" href="#Microbiome.taxrank-Tuple{GeneFunction}"><code>Microbiome.taxrank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">taxrank(gf::GeneFunction)</code></pre><p>Get the <code>rank</code> field from the <code>taxon</code> field of a <a href="#Microbiome.GeneFunction"><code>GeneFunction</code></a> <code>gf</code> if it has one. Returns <code>missing</code> if the <code>taxon</code> or <code>rank</code> is not set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.taxrank-Tuple{Taxon}" href="#Microbiome.taxrank-Tuple{Taxon}"><code>Microbiome.taxrank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">taxrank(t::Union{Taxon, missing})</code></pre><p>Get the <code>rank</code> field from a <a href="#Microbiome.Taxon"><code>Taxon</code></a> <code>t</code>. Returns <code>missing</code> if the rank is not set.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../humann/">« Working with HUMAnN</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Monday 7 March 2022 19:33">Monday 7 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
