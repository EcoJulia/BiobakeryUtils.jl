<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Microbiome.jl Docstrings · BiobakeryUtils.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BiobakeryUtils.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">BiobakeryUtils</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../metaphlan/">Working with MetaPhlAn</a></li><li><a class="tocitem" href="../humann/">Working with HUMAnN</a></li><li class="is-active"><a class="tocitem" href>Microbiome.jl Docstrings</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Microbiome.jl Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Microbiome.jl Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BioJulia/BiobakeryUtils.jl/blob/master/docs/src/microbiome.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Microbiome.jl-functions"><a class="docs-heading-anchor" href="#Microbiome.jl-functions">Microbiome.jl functions</a><a id="Microbiome.jl-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Microbiome.jl-functions" title="Permalink"></a></h1><p><code>BiobakeryUtils.jl</code> re-exports all of the functionality from <a href="https://github.com/BioJulia/Microbiome.jl"><code>Microbiome.jl</code></a>. The docstrings from that package are reproduced here, but checkout the <a href="https://biojulia.net/Microbiome.jl/latest/">Microbiome.jl docs</a> for more details.</p><article class="docstring"><header><a class="docstring-binding" id="Microbiome.CommunityProfile" href="#Microbiome.CommunityProfile"><code>Microbiome.CommunityProfile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CommunityProfile{T, F, S} &lt;: AbstractAbundanceTable{T, F, S}</code></pre><p>An <code>AbstractAssemblage</code> from <a href="https://github.com/EcoJulia/EcoBase.jl">EcoBase.jl</a> that uses an <code>AxisArray</code> of a <code>SparseMatrixCSC</code> under the hood.</p><p><code>CommunityProfile</code>s are tables with <code>AbstractFeature</code>-indexed rows and <code>AbstractSample</code>-indexed columns. Note - we can use the <code>name</code> of samples and features to index.</p><pre><code class="language-julia-repl hljs">julia&gt; txs = [Taxon(&quot;taxon$i&quot;) for i in 1:10];

julia&gt; mss = [MicrobiomeSample(&quot;sample$i&quot;) for i in 1:5];

julia&gt; mat = spzeros(10,5);

julia&gt; for i in 1:5; mat[i,i] = 1.; end

julia&gt; comm = CommunityProfile(mat, txs, mss)
CommunityProfile{Float64, Taxon, MicrobiomeSample} with 10 things in 5 places

Thing names:
taxon1, taxon2, taxon3...taxon9, taxon10

Place names:
sample1, sample2, sample3, sample4, sample5

julia&gt; comm[&quot;taxon1&quot;, &quot;sample1&quot;]
1.0

julia&gt; comm[:,[&quot;sample1&quot;, &quot;sample5&quot;]]
CommunityProfile{Float64, Taxon, MicrobiomeSample} with 10 things in 2 places

Thing names:
taxon1, taxon2, taxon3...taxon9, taxon10

Place names:
sample1, sample5

julia&gt; comm[Taxon(&quot;taxon3&quot;, :kingdom), &quot;sample1&quot;]
0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.GeneFunction" href="#Microbiome.GeneFunction"><code>Microbiome.GeneFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneFunction(name::String, taxon::Union{Taxon, String, Missing}) &lt;: AbstractFeature
GeneFunction(name::String)</code></pre><p>Microbial gene function object with optional stratification (<code>taxon</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.MicrobiomeSample" href="#Microbiome.MicrobiomeSample"><code>Microbiome.MicrobiomeSample</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MicrobiomeSample(name::String, metadata::Dictionary{Symbol, T}) &lt;: AbstractSample
MicrobiomeSample(name::String)</code></pre><p>Microbiome sample type that includes a name and a <a href="https://github.com/andyferris/Dictionaries.jl"><code>Dictionary</code></a> of arbitrary metadata using <code>Symbol</code>s (other than <code>:name</code> or <code>:metadata</code>) as keys.</p><p>Metadata can be accessed using <code>getproperty</code> or <code>getindex</code> on the sample itself.</p><pre><code class="language-julia-repl hljs">julia&gt; ms = MicrobiomeSample(&quot;sample1&quot;, Dictionary([:gender, :age], [&quot;female&quot;, 180]))
MicrobiomeSample(&quot;sample1&quot;, {:gender │ &quot;female&quot;, :age │ 180})

julia&gt; name(ms)
&quot;sample1&quot;

julia&gt; ms.name
&quot;sample1&quot;

julia&gt; ms.gender
&quot;female&quot;

julia&gt; ms.age
180</code></pre><p>Samples can be instantiated with only a name, leaving the <code>metadata</code> <code>Dictionary</code> blank</p><pre><code class="language-julia-repl hljs">julia&gt; ms2 = MicrobiomeSample(&quot;sample2&quot;)
MicrobiomeSample(&quot;sample2&quot;, {})</code></pre><p>Adding or changing metadata follows the same rules as for the normal <code>Dictionary</code> type.</p><ul><li>to change a value use <code>setproperty</code> or <code>setindex</code>. Note that this will fail if the key does not already exist.</li><li>to add or remove a value with validation that it does or does not exist already, use <code>insert!</code> and <code>delete!</code> respectively.</li><li>to add or remove a value without validation (&quot;upsert&quot;), use <code>set!</code> and <code>unset!</code> respectively.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; ms
MicrobiomeSample(&quot;sample1&quot;, {:gender │ &quot;female&quot;, :age │ 180})

julia&gt; ms.age = 16 * 365 # or `ms[:age] = 16 * 365`
5840

julia&gt; set!(ms, :gender, &quot;nonbinary&quot;)
MicrobiomeSample(&quot;sample1&quot;, {:gender │ &quot;nonbinary&quot;, :age │ 5840})

julia&gt; insert!(ms, :occupation, &quot;clerk&quot;)
MicrobiomeSample(&quot;sample1&quot;, {:gender │ &quot;nonbinary&quot;, :age │ 5840, :occupation │ &quot;clerk&quot;})

julia&gt; insert!(ms, :occupation, &quot;bagger&quot;)
ERROR: IndexError(&quot;Dictionary already contains index: occupation&quot;)

julia&gt; delete!(ms, :occupation)
MicrobiomeSample(&quot;sample1&quot;, {:gender │ &quot;nonbinary&quot;, :age │ 5840})

julia&gt; delete!(ms, :occupation)
ERROR: IndexError(&quot;Index doesn&#39;t exist: occupation&quot;)

julia&gt; unset!(ms, :occupation)
MicrobiomeSample(&quot;sample1&quot;, {:gender │ &quot;nonbinary&quot;, :age │ 5840})</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.Taxon" href="#Microbiome.Taxon"><code>Microbiome.Taxon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Taxon(name::String, clade::Union{Missing, Symbol, Int}) &lt;: AbstractFeature
Taxon(name::String)</code></pre><p>Microbial taxon with a name and a clade that can be one of </p><ol><li><code>:domain</code></li><li><code>:kingom</code></li><li><code>:phylum</code></li><li><code>:class</code></li><li><code>:order</code></li><li><code>:faamily</code></li><li><code>:genus</code></li><li><code>:species</code></li><li><code>:subspecies</code></li><li><code>:strain</code></li></ol><p>or <code>missing</code>. Contructors can also use numbers 0-9, or pass a string alone (in which case the <code>taxon</code> will be stored as <code>missing</code>)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.abundances" href="#Microbiome.abundances"><code>Microbiome.abundances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abundances(at::AbstractAbundanceTable)</code></pre><p>Get the underlying sparse matrix of an <code>AbstractAbundanceTable</code>. Note that this does not copy - any modifications to this matrix will update the parent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.braycurtis-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.braycurtis-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.braycurtis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">braycurtis(abt::AbstractAbundanceTable)</code></pre><p>Returns a pairwise Bray-Curtis dissimilarity matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.clade-Tuple{Taxon}" href="#Microbiome.clade-Tuple{Taxon}"><code>Microbiome.clade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clade(t::Union{Taxon, missing})</code></pre><p>Get the <code>clade</code> field from an <code>Taxon</code>. Returns <code>missing</code> if the clade is not set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.commjoin-Tuple{CommunityProfile, Vararg{CommunityProfile, N} where N}" href="#Microbiome.commjoin-Tuple{CommunityProfile, Vararg{CommunityProfile, N} where N}"><code>Microbiome.commjoin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commjoin(c1::CommunityProfile, comms::CommunityProfile...)</code></pre><p>Join multiple <code>CommunityProfile</code>s, creating a new <code>CommunityProfile</code>. For now, sample names cannot overlap in any of the input profiles.</p><pre><code class="language-julia-repl hljs">julia&gt; mss = [MicrobiomeSample(string(&quot;sample&quot;,i)) for i in 1:15];

julia&gt; txs = [Taxon(string(&quot;taxon&quot;,i)) for i in 1:20];

julia&gt; cm1 = CommunityProfile(spzeros(10,5), txs[1:10], mss[1:5])
CommunityProfile{Float64, Taxon, MicrobiomeSample} with 10 things in 5 places

Thing names:
taxon1, taxon2, taxon3...taxon9, taxon10

Place names:
sample1, sample2, sample3, sample4, sample5



julia&gt; cm2 = CommunityProfile(spzeros(10,5), txs[6:15], mss[6:10])
CommunityProfile{Float64, Taxon, MicrobiomeSample} with 10 things in 5 places

Thing names:
taxon6, taxon7, taxon8...taxon14, taxon15

Place names:
sample6, sample7, sample8, sample9, sample10



julia&gt; cm3 = CommunityProfile(spzeros(10,5), txs[11:20], mss[11:15])
CommunityProfile{Float64, Taxon, MicrobiomeSample} with 10 things in 5 places

Thing names:
taxon11, taxon12, taxon13...taxon19, taxon20

Place names:
sample11, sample12, sample13, sample14, sample15



julia&gt; commjoin(cm1, cm2, cm3)
CommunityProfile{Float64, Taxon, MicrobiomeSample} with 20 things in 15 places

Thing names:
taxon1, taxon2, taxon3...taxon19, taxon20

Place names:
sample1, sample2, sample3...sample14, sample15</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.featurenames" href="#Microbiome.featurenames"><code>Microbiome.featurenames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">featurenames(at::AbstractAbundanceTable)</code></pre><p>Get a vector of feature names from <code>at</code>, equivalent to <code>name.(features(at))</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.features-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.features-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.features</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">features(at::AbstractAbundanceTable)</code></pre><p>Returns features in <code>at</code>. To get featurenames instead, use <a href="#Microbiome.featurenames"><code>featurenames</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.featuretotals-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.featuretotals-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.featuretotals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">featuretotals(at::AbstractAbundanceTable)</code></pre><p>Returns sum of each row (feature) in <code>at</code>. Note, return value is a nfeatures x 1 <code>Matrix</code>, not a <code>Vector</code>. If you need 1D <code>Vector</code>, use <code>vec(featuretotals(at))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.ginisimpson!-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.ginisimpson!-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.ginisimpson!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ginisimpson!(abt::AbstractAbundanceTable; overwrite=false)</code></pre><p>Adds a <code>:ginisimpson</code> entry to the metadata for each sample in <code>abt</code> with the Gini-Simpson alpha diversity of that sample (see <a href="#Microbiome.ginisimpson-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T, Ti} where Ti}}, Tuple{T}} where T&lt;:Real"><code>ginisimpson</code></a>). If <code>overwrite=false</code> (the default), uses <code>insert!</code> to perform this operation, so an error will be thrown if any sample already contains a <code>:ginisimpson</code> entry. Otherwise, uses <code>set!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.ginisimpson-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T, Ti} where Ti}}, Tuple{T}} where T&lt;:Real" href="#Microbiome.ginisimpson-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T, Ti} where Ti}}, Tuple{T}} where T&lt;:Real"><code>Microbiome.ginisimpson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ginisimpson(v::Union{AbstractVector, AbstractSparseMatrix}) 
ginisimpson(abt::AbstractAbundanceTable, overwrite=false)</code></pre><p>Computes the Gini-Simpson alpha diversity metric for a vector. When called on an <code>AbstractAbundanceTable</code>, returns a 1 x nsamples matrix with 1 entry per sample. See also <a href="#Microbiome.ginisimpson!-Tuple{Microbiome.AbstractAbundanceTable}"><code>ginisimpson!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.hasclade-Tuple{Taxon}" href="#Microbiome.hasclade-Tuple{Taxon}"><code>Microbiome.hasclade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasclade(t::Taxon)::Bool</code></pre><p>Pretty self-explanatory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.hastaxon-Tuple{GeneFunction}" href="#Microbiome.hastaxon-Tuple{GeneFunction}"><code>Microbiome.hastaxon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hastaxon(t::GeneFunction)::Bool</code></pre><p>Pretty self-explanatory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.hellinger-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.hellinger-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.hellinger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hellinger(abt::AbstractAbundanceTable)</code></pre><p>Returns a pairwise Hellinger distance matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.jaccard-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.jaccard-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.jaccard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jaccard(abt::AbstractAbundanceTable)</code></pre><p>Returns a pairwise Jaccard distance matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.metadata-Tuple{AbstractSample}" href="#Microbiome.metadata-Tuple{AbstractSample}"><code>Microbiome.metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata(t::AbstractSample)</code></pre><p>Get the <code>metadata</code> field from an <code>AbstractSample</code>. Note that this is not a copy, so modifications to the returned value will update the parent <code>AbstractSample</code> as well.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.metadata-Tuple{CommunityProfile}" href="#Microbiome.metadata-Tuple{CommunityProfile}"><code>Microbiome.metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata(cp::CommunityProfile)</code></pre><p>Returns iterator of <code>NamedTuple</code> per sample, where keys are <code>:sample</code> and each metadata key found in <code>cp</code>. Samples without given metadata are filled with <code>missing</code>.</p><p>Returned values can be passed to any Tables.rowtable - compliant type, eg <code>DataFrame</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.name-Tuple{AbstractSample}" href="#Microbiome.name-Tuple{AbstractSample}"><code>Microbiome.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(t::Union{AbstractSample, AbstractFeature})</code></pre><p>Get the <code>name</code> field from an <code>AbstractSample</code> or <code>AbstractFeature</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.pcoa" href="#Microbiome.pcoa"><code>Microbiome.pcoa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pcoa(abt::AbstractAbundanceTable, f=braycurtis)</code></pre><p>Returns eigenvectors from fitting <code>MDS</code> to a distance metric generated by <code>f</code>, by default <code>braycurtis</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.present" href="#Microbiome.present"><code>Microbiome.present</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">present(t::Union{Real, Missing}, minabundance::Real=0.0)
present(at::AbstractAbundanceTable, minabundance::Real=0.0)</code></pre><p>Check if a given (non-zero) value is greater than or equal to a minimum value. If the minimum abundance is 0, just checks if value is non-zero.</p><p>If used on an <code>AbstractAbundanceTable</code>, returns a sparse boolean matrix of the same size.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.prevalence" href="#Microbiome.prevalence"><code>Microbiome.prevalence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prevalence(a::AbstractArray{&lt;:Real}, minabundance::Real=0.0)
prevalence(at::AbstractAbundanceTable, minabundance::Real=0.0)</code></pre><p>Return the fraction of values that are greater than or equal to a minimum. If the minimum abundance is 0, returns the fraction of non-zero values.</p><p>If used on an <code>AbstractAbundanceTable</code>, returns a prevalence value for each <code>feature</code> accross the <code>sample</code>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.prevalence_filter-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.prevalence_filter-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.prevalence_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevalence_filter(comm::AbstractAbundanceTable; minabundance=0.0; minprevalence=0.05, renorm=false)</code></pre><p>Return a filtered <code>CommunityProfile</code> where features with prevalence lower than <code>minprevalence</code> are removed. By default, a feature is considered &quot;present&quot; if &gt; 0, but this can be changed by setting <code>minabundance</code>.</p><p>Optionally, set <code>renorm = true</code> to calculate relative abundances after low prevalence features are removed.</p><pre><code class="language-julia-repl hljs">julia&gt; comm = CommunityProfile(sparse([3 0 1 # 0.33, assuming minabundance 2
                                       2 2 2 # 1.0
                                       0 0 1 # 0.0
                                       2 0 0 # 0.33
                                       ]),
                               [Taxon(string(i)) for i in 1:4],
                               [MicrobiomeSample(string(i)) for i in 1:3]);

julia&gt; prevalence_filter(comm, minabundance=2, minprevalence=0.3) 
CommunityProfile{Int64, Taxon, MicrobiomeSample} with 3 things in 3 places

Thing names:
1, 2, 4

Place names:
1, 2, 3

julia&gt; prevalence_filter(comm, minabundance=2, minprevalence=0.4)
CommunityProfile{Int64, Taxon, MicrobiomeSample} with 1 things in 3 places

Thing names:
2

Place names:
1, 2, 3

julia&gt; prevalence_filter(comm, minabundance=3, minprevalence=0.3)
CommunityProfile{Int64, Taxon, MicrobiomeSample} with 1 things in 3 places

Thing names:
1

Place names:
1, 2, 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.relativeabundance" href="#Microbiome.relativeabundance"><code>Microbiome.relativeabundance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relativeabundance(at::AbstractAbundanceTable, kind::Symbol=:fraction)</code></pre><p>Like <a href="#Microbiome.relativeabundance!-Tuple{Microbiome.AbstractAbundanceTable}"><code>relativeabundance!</code></a>, but does not mutate original.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.relativeabundance!-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.relativeabundance!-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.relativeabundance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relativeabundance!(a::AbstractAbundanceTable; kind::Symbol=:fraction)</code></pre><p>Normalize each sample in AbstractAbundanceTable to the sum of the sample.</p><p>By default, columns sum to 1.0. Use <code>kind=:percent</code> for columns to sum to 100.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.samplenames" href="#Microbiome.samplenames"><code>Microbiome.samplenames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">samplenames(at::AbstractAbundanceTable)</code></pre><p>Get a vector of sample names from <code>at</code>, equivalent to <code>name.(samples(at))</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.samples-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.samples-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">samples(at::AbstractAbundanceTable)</code></pre><p>Returns samples in <code>at</code>. To get samplenames instead, use <a href="#Microbiome.samplenames"><code>samplenames</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.sampletotals-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.sampletotals-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.sampletotals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampletotals(at::AbstractAbundanceTable)</code></pre><p>Returns sum of each row (feature) in <code>at</code>. Note, return value is a 1 x nsamples <code>Matrix</code>, not a <code>Vector</code>. If you need 1D <code>Vector</code>, use <code>vec(sampletotals(at))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.shannon!-Tuple{Microbiome.AbstractAbundanceTable}" href="#Microbiome.shannon!-Tuple{Microbiome.AbstractAbundanceTable}"><code>Microbiome.shannon!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shannon!(abt::AbstractAbundanceTable; overwrite=false)</code></pre><p>Adds a <code>:shannon</code> entry to the metadata for each sample in <code>abt</code> with the Shannon alpha diversity of that sample (see <a href="#Microbiome.shannon-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T, Ti} where Ti}}, Tuple{T}} where T&lt;:Real"><code>shannon</code></a>). If <code>overwrite=false</code> (the default), uses <code>insert!</code> to perform this operation, so an error will be thrown if any sample already contains a <code>:shannon</code> entry. Otherwise, uses <code>set!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.shannon-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T, Ti} where Ti}}, Tuple{T}} where T&lt;:Real" href="#Microbiome.shannon-Union{Tuple{Union{AbstractVector{T}, SparseArrays.AbstractSparseMatrix{T, Ti} where Ti}}, Tuple{T}} where T&lt;:Real"><code>Microbiome.shannon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shannon(v::Union{AbstractVector, AbstractSparseMatrix}) 
shannon(abt::AbstractAbundanceTable)</code></pre><p>Computes the Shannon alpha diversity metric for a vector. When called on an <code>AbstractAbundanceTable</code>, returns a 1 x nsamples matrix with 1 entry per sample. See also <a href="#Microbiome.shannon!-Tuple{Microbiome.AbstractAbundanceTable}"><code>shannon!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Microbiome.taxon-Tuple{GeneFunction}" href="#Microbiome.taxon-Tuple{GeneFunction}"><code>Microbiome.taxon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">taxon(t::Union{GeneFunction, missing})</code></pre><p>Get the <code>taxon</code> field from a <code>GeneFunction</code>. Returns <code>missing</code> if the taxon is not set.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../humann/">« Working with HUMAnN</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.9 on <span class="colophon-date" title="Tuesday 19 October 2021 17:14">Tuesday 19 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
